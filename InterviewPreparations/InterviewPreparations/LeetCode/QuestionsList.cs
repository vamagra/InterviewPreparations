using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace InterviewQuestions.LeetCode
{
    class QuestionsList
    {
        //3. Why are you interested in this position?

        //4. Why Coupang

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        // Design IEnumerator

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------
        //********************************************************************************************************************************************
        // Done -- Binary Tree Reverse Level Order Traversal - Given a binary tree, return the bottom-up level order traversal of its node values LeetCode107

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- Binary Tree Level Order Traversal - Top Down approach

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- Reversal of Linked List in groups of K. -- Leetcode

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- Clone a linked list with next and random pointer -- Leetcode

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- Construct a binary tree from given inorder and preorder traversals. -- Leetcode

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        // Done -- Construct a binary tree from given inorder and postorder traversals. -- Leetcode??????????????????????

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- SimplyFyPath - 71
        /* You are given an string as input which represents a path.
            You have to normalize that path inplace(NO EXTRA SPACE).
                e.g.input : "\a\b\c\..\..\file.txt" output: "\a\file.txt"*/

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- // Least common ancestor of two nodes in a binary search tree -- Leetcode 235
        // Least common ancestor of two nodes in a binary tree -- 
        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Binary Tree Vertical Order Traversal Leetcode - Leecode 314

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- // Find an element in a rotated array -- Leetcode 33

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done - Buy and Stock I -- Leetcode 121

        /* The cost of a stock on each day is given in an array, 
           find the max profit that you can make by buying and selling in those days. -- Leetcode
           For example, if the given array is { 100, 180, 260, 310, 40, 535, 695}, 
           the maximum profit can earned by buying on day 0, selling on
           day 3. Again buy on day 4 and sell on day 6. 
           If the given array of prices is sorted in decreasing order,
           then profit cannot be earned at all. */

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- Buy and Stock II -- Leetcode 122

        /*  Say you have an array for which the ith element is the price of a given stock on day i.
            Design an algorithm to find the maximum profit. You may complete as many transactions 
            as you like (ie, buy one and sell one share of the stock multiple times). 
            However, you may not engage in multiple transactions at the same time (ie, you must sell 
            the stock before you buy again).
         */
        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------
        //********************************************************************************************************************************************
        // Done -- Buy and Stock III -- Leetcode 123

        /* Say you have an array for which the ith element is the price of a given stock on day i.
            Design an algorithm to find the maximum profit. You may complete at most two transactions.
         */

        // Follow Up Question - Best Time to Buy and Sell Stock with Cooldown

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- Add Two Numbers in List I -- Leetcode 3
        // Given two linked lists both represent a number. Create a linked list that contains its sum. -- Leetcode

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- Add Two Numbers in List II - Leetcode 445
        /* You are given two non-empty linked lists representing two non-negative integers.The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
           You may assume the two numbers do not contain any leading zero, except the number 0 itself.
           Follow up:
           What if you cannot modify the input lists? In other words, reversing the lists is not allowed.*/

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        // Done -- Path Sum I 112

        //********************************************************************************************************************************************
        /* // Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that 
           // adding up all the values along the path equals the given sum.
            //  For example:
            //  Given the below binary tree and sum = 22,
            //              5
            //             / \
            //            4   8
            //           /   / \
            //          11  13  4
            //         /  \      \
            //        7    2      1
            //  return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
         */

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- Path Sum II 113

        /* Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.
        // For example:
        // Given the below binary tree and sum = 22,
        //              5
        //             / \
        //            4   8
        //           /   / \
        //          11  13  4
        //         /  \    / \
        //        7    2  5   1
        // return
        // [
        //   [5,4,11,2],
        //   [5,8,4,5]
         ] */

        // Done -- // Variation of PathSum II - Given a binary search tree , print the path which has the sum equal to k and has minimum hops. i.e if there are multiple paths with the sum equal 
        // to k then print the path with minimum number of nodes. -- Leetcode

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------
        //********************************************************************************************************************************************
        // Follow Up Path Sum III

        // and IV from Leetcode

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- A MxN matrix containing integers (positive, negative and zero’s). 
        // For every position containing 0, mark the corresponding row and column as 0. -- Leetcode - 73

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- Rotate MxN matrix by 90 degress. Leetcode - 48

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        // Done -- Convert a binary tree to its sum tree (each node is the sum of its children) geeksforGeeks

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        // Done -- Check if binary tree is sum tree (each node is the sum of its children) geeksforGeeks

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key 
        // plus sum of all keys greater than the original key in BST.  Leetcode - 538

        // Input: The root of a Binary Search Tree like this:
        //             5
        //           /   \
        //          2     14
        // Output: The root of a Greater Tree like this:
        //            19
        //           /   \
        //         21     14

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- Largest Number Leetcode - 179
        /*Given an array, arrange the elements such that the number formed by concatenating the elements is highest.
          E.g.: input = [9, 93, 24, 6],
          the output should be: [9,93,6,24].
          This is because if you concatenate all the numbers,
          993624 is the highest number that can be formed.*/

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- Given a string, find the longest substring which is palindrome. -- Leetcode - 5

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done  -- Given a string which consists of lowercase or uppercase letters, 
        // find the length of the longest palindromes that can be built with those letters. -- Leetcode -- 409

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- Write an efficient program for printing k largest elements in an array. Elements in array can be in any order.

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        // Done -- Remove duplicates from string in place in O(n).

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //********************************************************************************************************************************************
        //Done -- Given unsorted array and a number K. Find 2 numbers such that sum is K.


        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------
        /* Check whether given binary tree is balanced or not.  -- Leetcode
           Definition was no two leaves should have height difference of greater than one.*/

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //Given n-ary tree. zigzag level order traversal.

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //Given string s and string t find whether all permutation of t is present as substring in s.

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //Design a stack which holds an integer value such that getMinimum() function should return the minimum element in the stack.Implement popMin() function which would pop minimum element from the original stack.

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        // Given an array which is first strictly increasing and then strictly decreasing.Find an element in this array. This is not Array Rotation

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        // Given a series 2,3,4,5,6,8,9,10,……, here in this series all the numbers are present which have factors only and only either 2,3 or 5. Need to write a node to generate nth number for the series . With best approach and complexity

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //Merge k sorted arrays.

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //You are given a string of 0’s and 1’s you have to find the number of substrings in the string which starts and end with a 1.
        //eg : input : 0010110010 output : 6

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //You are given a mapping like a -> 1, b-> 2… z-> 26. You have to print all possible combinations of a given number using the above information.
        //eg : input : 121 output : aba, la, au

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //Given an unsorted array of n integers which can contain integers from 1 to n. Some elements can be repeated multiple times and some other elements can be absent from the array.Count frequency of all elements that are present and print the missing elements.
        //Examples:Input: arr[] = { 2, 3, 3, 2, 5}
        //    Output: Below are frequencies of all elements
        //1 -> 0        2 -> 2        3 -> 2        4 -> 0        5 -> 1

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //Given two strings in lowercase, the task is to make them anagram.The only allowed operation is to remove a character from any string. Find minimum number of characters to be deleted to make both the strings anagram?

        //If two strings contains same data set in any order then strings are called Anagrams.
        //Examples:
        //Input : str1 = "bcadeh" str2 = "hea"
        //Output: 3
        //We need to remove b, c and d from str1.
        //Input : str1 = "cddgk" str2 = "gcd"
        //Output: 2
        //Input : str1 = "bca" str2 = "acb"
        //Output: 0
        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------


        //Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
        //Examples:
        //Input: arr[]   = { 2, 0, 2}
        //    Output: 2
        //Structure is like below
        //| |
        //|_|
        //We can trap 2 units of water in the middle gap.
        //Input: arr[]   = {3, 0, 0, 2, 0, 4}
        //Output: 10
        //Structure is like below
        //     |
        //|    |
        //|  | |
        //|__|_| 
        //We can trap "3*2 units" of water between 3 an 2,
        //"1 unit" on top of bar 2 and "3 units" between 2 
        //and 4.  See below diagram also.

        //Input: arr[] = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
        //Output: 6
        //       | 
        //   |   || |
        //_|_||_||||||
        //Trap "1 unit" between first 1 and 2, "4 units" between
        //first 2 and 3 and "1 unit" between second last 1 and last 2

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------


        //This problem is know as Clock angle problem where we need to find angle between hands of an analog clock at a given time.
        //Examples:Input:  h = 12:00, m = 30.00
        //Output: 165 degreeInput:  h = 3.00, m = 30.00 Output: 75 degree
        //————————————————————————————————

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //Set Mismatch - Find the duplicate and missing number from a given set of integers originally having set of 1 to n. LeetCode645

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //Serialize and De-serialize Binary Tree - Serialize a binary tree to a doubly linked list and De-serialize it back to same tree.Variation of LeetCode297

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //Insert Delete GetRandom O(1) - Design a data structure that supports insert(val), remove(val) and getRandom() in average O(1) LeetCode381

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //Path Sum - Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.LeetCode112

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //Longest Palindromic Subsequence - Given a string s, find the longest palindromic subsequence's length in s. LeetCode516

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------
        //Longest Increasing Path in a Matrix - Given an integer matrix, find the length of the longest increasing path. LeetCode329

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //Merge k Sorted Lists - Merge k sorted linked lists and return it as one sorted list.LeetCode023

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //1. Convert an integer as it speaks out 1234 to One thousand Two hundred thirty four  
        //Integer to English Words - Convert a non-negative integer to its English words representation LeetCode273 <Done>

        //********************************************************************************************************************************************

        //2. In order Traversal Tree Print with no recursion, typical LeetCode94<Done> 

        //********************************************************************************************************************************************

        //5. Given an array of numbers, move all the zeros to the right. LeetCode283 <Done>

        //********************************************************************************************************************************************

        //6. You are given an integer array.You have to return/print an array where kth element of this array is the multiplications of all the elements from 0 to k-1 and from k+1 to n-1.             
        //   Example   input: [1 2 5 6] output: [60 30 12 10] LeetCode238<Done> **************

        //********************************************************************************************************************************************

        // Merge Two Sorted Array - Merge two sorted array in first array, given that first array has space to 
        // add all elements of second array. LeetCode88 <Done> *********************

        //********************************************************************************************************************************************

        //Find All Anagrams in a String - Given a string s and a non-empty string p, 
        //Find all the start indices of p's anagrams in s. LeetCode438 *************************

        //********************************************************************************************************************************************

        //LRU Cache - Design and implement a data structure Least Recently Used(LRU) cache with get and put method.LeetCode146 

        //********************************************************************************************************************************************

        //Two Sum - return pair of numbers such that they adds up to a target number LeetCode001  

        //********************************************************************************************************************************************

        //********************************************************************************************************************************************

        // Implement pow(x, n) - Optimized solution with recursion LeetCode050 <Done>

        //********************************************************************************************************************************************

        // Odd Even Linked List - Given a singly linked list, group all odd nodes together followed by the even nodes LeetCode328 <Done>

        //********************************************************************************************************************************************

        // House Robber - LeetCode198 <Done>

        //********************************************************************************************************************************************

        //Spiral Matrix - Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order LeetCode054 <Done>

        //********************************************************************************************************************************************

        //How would you check a loop in doubly Linked list <Done>

        //********************************************************************************************************************************************

        //Is Valid Palindrome - Given a string, determine if it is a palindrome LeetCode125<Done>

        //********************************************************************************************************************************************

        //First Unique Character in a String - Given a string, find first non-repeating character and return its index. LeetCode387 <Done>

        //********************************************************************************************************************************************

        //7. Write a function that calculates exponents.

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //8. Design an airline reservation system. 
        // REF - 1. https://codereview.stackexchange.com/questions/25978/airline-reservations-system
        // REF - 2. https://github.com/wishyouhappy/AirlineReservation 
        //********************************************************************************************************************************************

        // Implement Throttling - Design Data Structure and Algorithm for implementing throttling.

        //********************************************************************************************************************************************

        // Design Data Structure for throttling - Design a data structure for throttling requests exceeding given threshold or queries per second.

        //********************************************************************************************************************************************

        // Merge and Sort Search Results - Merge, and Sort Search results from different markets to make one search result.
        //********************************************************************************************************************************************

        // Evaluate Given Expression - Given an expression with +, * and @ operations.
        //********************************************************************************************************************************************

        // Find Dominant Language - Given phrase and API to give confidence percentage of dominant languages in given line, return dominant language of phrase.

        //********************************************************************************************************************************************

        // String to Number - Convert given string to number (integer, double)

        //********************************************************************************************************************************************

        // Find Word Count - For given word, find its count from a very large file which cannot be loaded in memory.

        //********************************************************************************************************************************************

        // Find longest substring with two unique characters - Given a string, find a longest substring with maximum two unique characters.Variation of LeetCode003

        //********************************************************************************************************************************************

        // Find words made using given characters - Given list of words, return words which can be made using just characters from given character array.

        //********************************************************************************************************************************************

        // Minimum distance - Find minimum distance between two given integers in a given integer array.

        //********************************************************************************************************************************************

        // Can Knight Cover all Chess Board - Given a Knight's initial position in a chess board, check return true if Knight can cover all squares in the board with all possible moves.

        //********************************************************************************************************************************************

        // 25 Horses Problem - GeeksforGeeks

        //********************************************************************************************************************************************

        // Save all leaf nodes of a Binary tree in a Doubly Linked List by using Right node as Next node and Left Node as Previous Node.

        //********************************************************************************************************************************************

        // Given an array, find the maximum j – i such that arr[j] > arr[i]

        //********************************************************************************************************************************************

        // Remove Alternate Duplicate characters from a char array you have to do it in Place.Like keeping only the odd occurences of each character.
        // Example: Input: “you got beautiful eyes”
        // Output: ”you gtbeaiful es”
        // Allowed Time Complexity was O(n) and Space Complexity was O(1)

        //********************************************************************************************************************************************

        // In a file there are 1 million words.Find 10 most frequent words in that file.

        //********************************************************************************************************************************************

        // Find all nodes at k-distance from a given node in a binary tree

        //********************************************************************************************************************************************

        // Serialise and Deserialise a linked list with next and random pointer.

        //********************************************************************************************************************************************

        // Return a tree such that each internal node stores sum of all its child nodes.Each leaf node stores zero.

        //********************************************************************************************************************************************

        // How will you implement linked list with 1 million nodes? How will you access 999999 th node? Give some optimal design strategy and implementation.

        //********************************************************************************************************************************************

        // Given a positive integer N, count all possible distinct binary strings of length N such that there are no consecutive 1’s.

        //********************************************************************************************************************************************

        // Connect nodes on same level in a binary tree.

        //********************************************************************************************************************************************

        // Find sum of data of all leaves of a binary tree on same level and then multiply sums obtained of all levels.

        //********************************************************************************************************************************************

        // Given a matrix of characters and a word.
        // you have to count the number of occurrences of that word in that matrix. you can move to any of the eight valid directions from current position.

        //********************************************************************************************************************************************

        // Given two sorted arrays(with repetitive elements) find the kth minimum number from both arrays.

        //********************************************************************************************************************************************

        // Given the root to a binary tree, a value n and k.Find the sum of nodes at distance k from node with value n

        //********************************************************************************************************************************************

        // Find the nth number that contains the digit k or is divisible by k. (2 <= k <= 9)

        //********************************************************************************************************************************************

        // Write a program to connect next left node in a binary tree.Also first node of each level should be pointing to last node of next level? (Without using Queue)

        //********************************************************************************************************************************************

        // Given a directed graph.Construct another graph from given graph such that if path exists from vertices A to vertices B and from B to C, then path from A to C and from C to A also should exists.

        //********************************************************************************************************************************************

        // Implement hashmap on your own.Write good hashing function for string.

        //********************************************************************************************************************************************

        // Given that integers are read from a data stream.Find median of elements read so for in efficient way. For simplicity assume there are no duplicates.

        //********************************************************************************************************************************************

        // Given a set of intervals like 5-10, 15-20, 25-40, 30-45, 50-100. Find the ith smallest number in these intervals. Assume there are no duplicate numbers.
        // e.g:  1st smallest number = 5	  6th smallest number = 10	
        // 7th smallest number = 15 and so on.

        //********************************************************************************************************************************************
        // Given a string example : shoppingwithflipkartiseasy, Now we are given this string and a dictionary containing valid words , now we need to break the sentence into words separated by space.Output : shopping with flipkart is easy

        //********************************************************************************************************************************************

        // Given a tree with edge weights, find any path in the tree with maximum sum of edges.

        //********************************************************************************************************************************************

        // Given a maze, a start point and end point find the shortest path to reach the end point from the starting point.

        //********************************************************************************************************************************************

        // Given a sentence and a set of characters. Find the minimum window within which the set of characters can be found in the sentence in any order.

        //********************************************************************************************************************************************

        // Given a dictionary of 50,000 words.Given a phrase without spaces, add spaces to make it a proper sentence.
        // e.g:input:  thequickbrownfoxjumpoverlazydog
        // output: the quick brown fox jump over lazy dog
        // Get the next bigger number using the same digits of a number.
        // Eg, For 123456, next number would be 123465

        //********************************************************************************************************************************************

        // Given a boolean 2D matrix, find the number of islands.A group of connected 1s forms an island.For example, the below matrix contains 5 islands
        // Input : mat[][] =
        //{
        //        { 1, 1, 0, 0, 0},
        // { 0, 1, 0, 0, 1}, 
        //  { 1, 0, 0, 1, 1},
        //  { 0, 0, 0, 0, 0}, 
        // { 1, 0, 1, 0, 1}
        //    }
        //    Output : 5

        //********************************************************************************************************************************************

        // Given two strings str1 and str2 and below operations that can performed on str1. Find minimum number of edits (operations) required to convert ‘str1’ into ‘str2’.
        //Insert
        //Remove
        //Replace
        //All of the above operations are of equal cost.
        //Examples:
        //Input:   str1 = "geek", str2 = "gesek"
        //Output:  1
        //We can convert str1 into str2 by inserting a 's'.
        //Input:   str1 = "cat", str2 = "cut"
        //Output:  1
        //We can convert str1 into str2 by replacing 'a' with 'u'.
        //Input:   str1 = "sunday", str2 = "saturday"
        //Output:  3
        //Last three and first characters are same.We basically
        //need to convert "un" to "atur".  This can be done using
        //below three operations.
        //Replace 'n' with 'r', insert t, insert a
        // Given a string with repeated characters, task is rearrange characters in a string so that no two adjacent characters are same.
        //Note : It may be assumed that the string has only lowercase English alphabets.
        //Examples:
        //Input: aaabc
        //Output: abaca
        //Input: aaabb
        //Output: ababa
        //Input: aa
        //Output: Not Possible
        //Input: aaaabc
        //Output: Not Possible

        //********************************************************************************************************************************************

        //--------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //https://coding-interview-solutions.hackingnote.com/problems/clone-binary-tree.html

        #region Done Questions
        //  http://www.lintcode.com/zh-cn/problem/two-sum/ - Done
        //  http://www.lintcode.com/zh-cn/problem/binary-tree-serialization/ - Done
        //  http://www.lintcode.com/zh-cn/problem/number-of-islands/ - Done
        //  http://www.lintcode.com/zh-cn/problem/valid-parentheses/ - Done
        //  http://www.lintcode.com/zh-cn/problem/copy-list-with-random-pointer/ - Done
        //  http://www.lintcode.com/zh-cn/problem/rotate-image/ - Done 
        //  http://www.lintcode.com/zh-cn/problem/longest-palindromic-substring/ - Done
        //  http://www.lintcode.com/zh-cn/problem/best-time-to-buy-and-sell-stock/ - Done
        //  http://www.lintcode.com/zh-cn/problem/sliding-window-maximum/ - Done
        //  http://www.lintcode.com/zh-cn/problem/letter-combinations-of-a-phone-number/
        //  http://www.lintcode.com/zh-cn/problem/reverse-linked-list/ - Done
        //  http://www.lintcode.com/zh-cn/problem/search-a-2d-matrix-ii/ - Done
        //  http://www.lintcode.com/zh-cn/problem/trapping-rain-water/ - Done
        //  http://www.lintcode.com/zh-cn/problem/intersection-of-two-linked-lists/ - Done
        //  http://www.lintcode.com/zh-cn/problem/linked-list-cycle/ - Done
        //  http://www.lintcode.com/zh-cn/problem/add-two-numbers/ - Done
        //  http://www.lintcode.com/zh-cn/problem/kth-largest-element/ - Done
        //  http://www.lintcode.com/zh-cn/problem/palindrome-linked-list/ - Done
        //  Algorithm 8: Leetcode 49 Group anagrams - Done
        //  Algorithm 9: Leetcode54 SpiralMatrix - Done
        //  Algorithm 19: Binary tree two path same value - Done
        //  Algorithm 20: Leetcode 239 Sliding window maximum - Done
        //  WAP to find if a string has all unique characters.
        #endregion

        #region Hard Algorithm

        //  http://www.lintcode.com/zh-cn/problem/word-ladder/ - 
        //  http://www.lintcode.com/zh-cn/problem/word-ladder-ii/ 
        //  http://www.lintcode.com/zh-cn/problem/validate-binary-search-tree/
        //  http://www.lintcode.com/zh-cn/problem/merge-k-sorted-lists/
        //  http://www.lintcode.com/zh-cn/problem/lfu-cache/ - 
        //  http://www.lintcode.com/zh-cn/problem/lowest-common-ancestor/ -
        //  http://www.lintcode.com/zh-cn/problem/min-stack/ - 

        //  Algorithm 1. In order successor
        //  Algorithm 2. Flatten the dictionary
        //  Algorithm 3: HTree
        //  Algorithm 4: Reverse words
        //  Algorithm 5. Find distance binary tree
        //  Algorithm 6. Leetcode 23 Merge K Sorted List
        //  Algorithm 7: Leetcode 37 Sudoku
        //  Algorithm 10: Leetcode 72 Edit distance
        //  Algorithm 11: Leetcode 114 Flatten Binary Tee to Linked List
        //  Algorithm 12: Leetcode 212 Word Search II
        //  Algorithm 13: Leetcode 295 Find median for path stream
        //  Algorithm 14: Leetcode 295 median of stream
        //  Algorithm 15. Leetcode 300 Longest Increasing Subsequence
        //  Algorithm 16. Leetcode 416 Partition equal subset sum
        //  Algorithm 17: Leetcode 516 Longest palindrome subsequence
        //  Algorithm 18: Leetcode 605 Can place flowers
        //  Algorithm 21: Leetcode 57   Insert interval
        //  Algorithm 22: Leetcode 10   Regular expression matching
        //  Algorithm 23: Leetcode 547 Find Circle
        //  Algorithm 24: Leetcode 130 Surrouned region
        //  Algorithm 25: Maze Project
        //  Algorithm 26: Short Job First using Icomparer
        //  Algorithm 27: Leetcode 554 Brick wall

        #endregion

        #region  String Program
        //1-    WAP to find if a string has all unique characters.-- Done
        //2-	WAP to reverse a string. (using temp variable or XOR) -- Done (Leetcode 344)
        //3-	Given two string, WAP to find if one is anagram of other. -- Done (Leetcode 242)
        //4-	Implement a method to perform basic string compression using the counts of repeated characters. -- Done (Leetcode 443)
        //      For ex: the string aabcccccaaa would become a2b1c5a3.
        //5-	Remove duplicate characters from a string - Done
        //6-	You are given a string. You have to eliminate the pairs (two same chars adjacent to each other). eg.input string RGBBGBGR –> RGGBGR–> RBGR(output)
        //a.We can do it using STACK, before push character check if top character is matching then pop() else push. -- Done
        //7-	WAP to Reverse words like “This is a boy” will convert to “sihT si a yob” -- Done (Leetcode = 557)
        //a.Reverse one word at a time
        //8-	Reverse string order like “Dowry is  a string” will convert as “string a is Dowry” - Done
        //a.Reverse complete string then reverse words
        //9-	WAP to remove space from string - Done
        //10-	WAP to find first non-repeating characters, eg: “GeeksforGeeks” , Answer : f - Done (Leetcode - 387)
        //a.Solution: Create an array of int (Size:128), use index number for character and store position as value, if character is seen then store 0 because we don’t care for repeating character
        //11-	WAP to find Excel column name from a given column number, eg: 28  => AC -- Done (Leetcode - 168)
        //12-	Check if anagram of string is Palindrome or not. -- Done
        //a.Eg : “aaaad” is palindrome anagram but “abcd” is not
        //b.Solution: for palindrome string odd character occurrence should not be more than 1 means count the occurrence of each character and check if al occurrence are divisable by 2 or now if you found more than 1 odd occurrence then answer is false
        //13-	Group Anagrams - Given a dictionary with set of words in it.Write a program to group all words which are anagrams -- Done (Leetcode - 49)
        //      of each other in to sets. 
        //a.Input: “bat”, “tar”, “xyz” , “tab”, “tar”
        //b.Output:[["bat", tab"], ["tar", rat"],”xyz” ]
        //c.SOLUTION: Create a hash table and calculate key as sum of ascii value of string characters if string has same characters the sum of asci value would be same so add the word against same key.
        //14-	WAP to find longest Palindrome substring in string. -- Done (Leetcode - 5)
        //15-	Given a string consisting of opening and closing parenthesis, find length of the longest valid parenthesis substring. -- Done (Leetcode - 32)
        //a.Input : ((()  , Output : 2
        //b.Input: )()())  , Output : 4
        //c.The idea is to store indexes of previous starting brackets in a stack.The first element of stack is a special element that provides index before beginning of valid substring (base for next valid string).
        //16-	Given an expression with only ‘}’ and ‘{‘. The expression may not be balanced. -- Done
        // Find minimum number of bracket reversals to make the expression balanced
        //a.Input:  exp = "}{"  Output : 2, We need to change '}' to '{' and '{' to '}' so that the expression becomes balanced, the balanced expression is '{}'
        //b.Input:  exp = "{{{" Output : Expression can't be balanced
        //17-	Given a string, that contains special character together  -- Done
        //with alphabets (‘a’ to ‘z’ and ‘A’ to ‘Z’), reverse the string in a way that special characters are not affected
        //a.Input:   str = "a,b$c", Output : "c,b$a"
        //b.Input:   str = "Ab,c,de!$"  Output:  str = "ed,c,bA!$"
        //18-	Given two strings A and B, the task is to convert A to B if possible. -- Done
        //a.The only operation allowed is to put any character from A and insert it at front.
        //b.Find if it’s possible to convert the string. If yes, then output minimum no. of operations required for transformation.
        //c.Input : str1= EACBD, str2= EABCD : Output : 3
        //19. Maximum Repeating Character in string -- Done
        //20. Concatenation of two strings - Done
        //21. Reverse a String -- Done
        //22. Remove duplicates from a string -- Done
        //23. Palindrome String -- Done
        //24. Sorting the array of strings - you can do it using Bubble Sort -- Done
        //25. Remove characters from first string which are in second - Done
        //26. Print Reverse of a string (Recursion) - Dpne
        //27. Divide a string in N equal parts -- Done
        //28. Reverse words in a given string -- Done
        //29. Given a string find its first non-repeating character -- Done
        //30. Check whether two strings are anagram of each other -- 
        //31. Print all duplicates in the input string -- 
        //32. Longest Palindromic Substring -- 
        //33. Run length encoding -- Done
        //34. Sort an array of strings -- Done
        //35. Remove spaces from a string -- Done
        //36. The smallest window in a string containing all characters of another string -- Done (Leetcode - 76)
        //37. A Program to check if strings are rotations of each other or not -- Not Done
        //38. Print all interleavings of given two strings -- Done
        //39. List items containing all characters of a given word -- Done
        //40. Given string is interleaving of two other strings or not -- Done (without duplicate characters in string)
        //41. Remove 'b' and 'ac' from a given string -- Done
        //42. Recursively remove all adjacent duplicates



        //9 -	WAP to print permutation of string
        //10-	WAP to search a pattern in string using Boyer Moore algo.
        //11-	WAP to search pattern in string (Naïve method)
        //12-	WAP to search pattern in string using KMP algorithm
        //22-	Given a list of tickets, find itinerary in order using the given list.
        //a.Input:
        //b.  "Chennai" -> "Banglore"
        //c.  "Bombay" -> "Delhi"
        //d.  "Goa"    -> "Chennai"
        //e.  "Delhi"  -> "Goa"
        //f.Output: Bombay->Delhi, Delhi->Goa, Goa->Chennai, Chennai->Banglore
        //24 -	Find the minimum edit distance to convert first string into another
        //a.	Input: str1= APPLE BEE, str2= LE BEE : output : 3
        // Print all permutations with repetition
        // wildcard character matching





        // Check if a given string is a rotation of a palindrome
        // Find the second most frequent character
        // Print all pair of anagrams in a given array of strings
        // Lexicographic rank of string
        // Print all anagrams together in a sequence of words
        // Count the number of words
        // String(represents an integer) to value
        // Palindromes in a given range
        // Check rearranged string can form a palindrome
        // print all palindromic partitions
        // Minimum insertions to form a shortest palindrome
        // Print string of odd length in 'X' format
        // Transform one string to another using minimum number of given operations
        // Shortest Superstring Problem
        // Print all possible words from phone digits
        // Palindrome string (number)
        // Number of sub-strings which recursively add up to 9
        // Rotate string to get lexicographically minimum string
        // Print Longest common subsequence
        // Recursive function to do substring search
        // Reverse a string without affecting special characters
        // Recursive Implementation of atoi()
        // Program to add two binary digits
        // Length of longest valid substring
        // Check if two given strings are isomorphic to each other
        // Online algorithm for checking palindrome in a stream
        // Recursively print all the sentences that can be formed from list of word lists
        // Remove recurring digits in a given number
        // Find First non-repeating character in a string
        // Convert string1 to string2 in one edit
        // 1`s and 2`s complement of binary number
        // Split a string
        // Palindrome permutations of a string
        // Repeated subsequence of length 2 or more
        // PANGRAM CHECK
        // Longest Common Extension
        // Removing spaces from a string using stringstream
        // Count number of substrings with k distinct characaters
        // Change gender of a given string
        // Remove Extra Spaces from a string
        // Print shortest path to print a string on screen
        // Longest Common Prefix(Using Biary Search)
        // Lower Case To Upper Case
        // Longest Common Prefix(Using Divide and Conquer)
        // Calculate sum of all numbers present in a string
        // Permutations(STL)
        // Longest common prefix(Character by character)
        // Longest common prefix(word by word)
        // Longest palindrome can be formed by removing or rearranging characters
        // Perfect reversible string
        // Longest common subsequence withpermutations
        // Caesar Cipher
        // Print all possible ways to break a string in bracket form
        // Generate all binary strings from given pattern
        // Remove minimum characters so that two strings become anagrams
        // Compare two version numbers
        // Kth Non-repeating character
        // Nth character in Concatenated Decimal string
        // Convert a string that is repetition of a substring of length k
        // Minimum characters to be added at front to make string palindrome
        // Count of character pairs at same distance as in english alphabets
        // Print all palindromic partitions of a string
        // Minimum number of characters to be removed to make a binary string alternate
        // Recursive Palindrome check
        // Reverse string without temporary variable
        // Can be split into four distinct strings
        // Even sub-string count
        // Check if string follows order of characters by a pattern or not
        // Smallest palindrome after replacement
        // Check if string can become empty by recursively deleting given sub-string
        // Sort a string according to another string
        // Check if all rows of a matrix are circular rotations of each other
        // Generate all binary strings without consecutive 1's
        // Check length of a string is equal to the number appended at its last
        // Program to toggle all characters in a string
        // Check whether strings are k distance apart or not

        #endregion

        #region Array/Matrix Program
        //1-	WAP to rotate a matrix clock wise on 90 degree
        //2-	Write an algorithm such that is an element in an MxN matrix is 0, its entire row and column set to 0.
        //a.We can do it in two ways:
        //i.Create two bool array one for row and other for col, iterate matric and set row position and col position as TRUE in respective array wherever matrix has 0. Then iterate matrix again and set matrix value 0 wherever row and column position in bool array is TRUE.
        //ii.We can do the same thing using two integer variable that can hold row numbers and column numbers wherever 0 found.
        //3-	Find missing number from an sequence array
        //4-	WAP to sort an array using Bubble Sort O(n2)
        //5-	WAP to sort an array using selection sort O(n2)
        //6-	WAP to sort an array using Insertion Sort O(n2)
        //7-	WAP to sort an array using Merge Sort O(n log n)
        //8-	WAP to sort an array using Quick sort O(n log n)
        //9-	WAP to find out the number which occurs only one time in pair array
        //10-	WAP to print matrix in spiral form
        //11-	WAP to search a number in sorted array(Binary Search)
        //12-	WAP to search first occurrence of a number in Binary Search
        //13-	WAP to search last occurrence of a number in Binary Search
        //14-	WAP to count number of occurrence of a number using Binary Search in sorted array
        //15-	WAP to Binary Search a number(Recursive)
        //16-	Write a C program that, given an sorted array A[] of n numbers and another number x, determines whether or not there exist two elements in S whose sum is exactly x.
        //17-	Write a C program that, given an unsorted array A[] of n numbers and another number x, determines whether or not there exist two elements in S whose sum is exactly x.
        //18-	Write an efficient C program to find the sum of contiguous subarray within a one-dimensional array of numbers which has the largest sum
        //a.	Kadane’s algorithm works only when there is at least one positive number
        //19-	Rotate an sorted array by D times using temp buffer
        //20-	Rotate sorted array by D time one by one
        //21-	Count frequencies of all elements in array.Given an unsorted array of n integers which can contain integers from 1 to n.Some elements can be repeated multiple times and some other elements can be absent from the array. Count frequency of all elements that are present and print the missing elements.
        //a.One Solution : A Simple Solution is to create a count array of size n as the elements are in range from 1 to n. This solution works in O(n) time, but requires O(n) extra space.
        //22-	Find the nearest smaller numbers on left side in an array
        //a.Better solution : Using STACK
        //23-	Sort an almost sorted array where only two elements are swapped
        //24-	Find the largest pair sum in an unsorted array.Given an unsorted array, find the largest pair sum in it.For example, the largest pair sum in { 12, 34, 10, 6, 40} is 74  (34 + 40). This problem is to find first and second larget number and sum them
        //25-	Write a program to find out how many times a sorted array has been rotated.Algo : find the minimum number in array and index of this number will be count of rotation.
        //26-	An element in a sorted array can be found in O(log n) time via binary search. But suppose I rotate the sorted array at some pivot unknown to you beforehand. So for instance, 1 2 3 4 5 might become 3 4 5 1 2. Devise a way to find an element in the rotated array in O(log n) time.
        //a.	Find the pivot point, divide the array in two sub-arrays and call binary search.
        //b.	The main idea for finding pivot (call Find ArrayRotationCount() - 1),
        //c.	pivot element is the only only element for which next element to it is smaller than it.
        //27-	Given an array A []
        //consisting 0s, 1s and 2s, write a function that sorts A [].The functions should put all 0s first, then all 1s and all 2s in last.
        //a.	Input = { 0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1};
        //b.	Output = { 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2}
        //28-	You are given an array of 0s and 1s in random order. Segregate 0s on left side and 1s on right side of the array. Traverse array only once.
        //a.	METHOD1: Count 0's in variable 'T' by traversing array once and then traverse array again to fill starting T elements with 0 band rest with 1. In above method you have to traverse Array twice.
        //b.	METHOD 2: Maintain two indexes. Initialize first index left as 0 and second index right as n-1.
        //i.	Do following while left < right
        //ii.	Keep incrementing index left while there are 0s at it
        //iii.	Keep decrementing index right while there are 1s at it
        //iv.	If left < right then exchange arr [left]
        //and arr [right]
        //Implementation
        //29-	Search in a row wise and column wise sorted matrix. Given an n x n matrix, where every row and column is sorted in increasing order. Given a number x, how to decide whether this x is in the matrix.
        //a.	1) Start with top right element
        //b.	2) Loop: compare this element e with x
        //c.	if they are equal then return its position
        //d.	e < x then move it to down (if out of bound of matrix then break return false)
        //e.	e > x then move it to left (if out of bound of matrix then break return false)
        //30-	WAP to print leader elements in an Array, An element is leader if it has value greater than the right elements, right most element is always a leader.
        //31-	Given an unsorted array and a number n, find if there exists a pair of elements in the array whose difference is n. return count of such pairs.
        //32-	Euclid’s Algorithm to calculate GCD when % and / operations are costly
        //33-	You are given an array of n+2 elements. All elements of the array are in range 1 to n and all elements occur once except two numbers which occur twice. Find the two repeating numbers.
        //34-	Given an array of n distinct integers sorted in ascending order, write a function that returns a Fixed Point in the array, if there is any Fixed Point present in array, else returns -1. Fixed Point in an array is an index i such that arr [i] is equal to i. Note that integers in array can be negative.
        //a.	Binary Search : First check whether middle element is Fixed Point or not. If it is, then return it; otherwise check whether index of middle element is greater than value at the index. If index is greater, then Fixed Point(s) lies on the right side of the middle point (obviously only if there is a Fixed Point). Else the Fixed Point(s) lies on left side.
        //b.	Input: arr [] = { -10, -5, 0, 3, 7}, Output: 3  // arr[3] == 3 
        //35-	Given two arrays: arr1 [0..m-1]
        //and arr2 [0..n-1]. Find whether arr2 [] is a subset of arr1 []
        //or not. Both the arrays are not in sorted order. It may be assumed that elements in both array are distinct.
        //a.	(Use Sorting and Binary Search)
        //b.	Sort Array
        //c.	For each element in Array2 do Binary search for it in Array1
        //d.	If all present then return 1
        //36-	Given an array arr []
        //of n integers, construct a Product Array prod [] (of same size) such that prod [i] is equal to the product of all the elements of arr []
        //except arr [i]. Solve it without division operator and in O(n).
        //37-	Given an unsorted array of integers, sort the array into a wave like array.
        //38-	We have an array arr [0 . . . n-1]. We should be able to efficiently find the minimum value from index L (query start) to R (query end) where 0 <= L <= R <= n-1. Consider a situation when there are many range queries
        //a.	Input:  arr []   = { 7, 2, 3, 0, 5, 10, 3, 12, 18}; query [] = [0, 4], [4, 7], [7, 8]
        //b.	Output: Minimum of [0, 4] is 0, Minimum of [4, 7] is 3, Minimum of [7, 8] is 12
        //c.	A Simple Solution is to create a 2D array lookup []
        //[]
        //where an entry lookup [i]
        //[j]
        //stores the minimum value in range arr [i..j]. Minimum of a given range can now be calculated in O(1) time.
        //39-	Fibonacci coding encodes an integer into binary number using Fibonacci Representation of the number
        //40-	Given a sorted array arr[] of siz n and an element x to be searched in it.Return index of x if it is present in array else return -1.
        //a.Use Fibonacci Search method.
        #endregion

        #region Linklist
        //1-	Remove duplicate node from unsorted linklist with temporary buffer
        //2-	Remove duplicate from unsorted link list where temporary buffer not allowed
        //3-	WAP to delete node from linklist
        //4-	Write a Function to add two numbers given in a linklist
        //a.Input:  First List: 5->6->3  // represents number 365
        //b.Second List: 8->4->2 //  represents number 248
        //c.Output Resultant list: 3->1->6  // represents number 613
        //5-	Write a program to check if given linklist is palindrome
        //6-	Function to pairwise swap elements of a linked list
        //7-	Implement an algorithm to find the nth to last element of a singly linked list.
        //8-	Reverse Link List (Iterative Method)
        //9-	Reverse Link List(Recursive Method)
        //10-	Write a Function to swap nodes x and y in linked list by changing links
        //a.Input:  10->15->12->13->20->14, x = 12, y = 20
        //b.Output: 10->15->20->13->12->14
        //11-	Function to reverse all even positioned node and append at the end odd is the head node of given linked list.
        //a.Input List:  1->2->3->4->5->6
        //b.Output List: 1->3->5->6->4->2
        //12-	Function to sort a linked list of 0s, 1s and 2s
        //a.	Traverse the list and count the number of 0s, 1s and 2s.Let the counts be n1, n2 and n3 respectively.
        //b.Traverse the list again, fill the first n1 nodes with 0, then n2 nodes with 1 and finally n3 nodes with 2.
        //13-	The function removes duplicates from a sorted list
        //14-	Find a loop in single linklist
        //15-	find the begining point of the loop.
        //16-	Reverse a Linked List in groups of given size Given a linked list, write a function to reverse every k nodes (where k is an input to the function).
        //a.Inputs:  1->2->3->4->5->6->7->8->NULL and k = 3
        //b.Output:  3->2->1->6->5->4->8->7->NULL
        //17-	Reverse alternate K nodes in a Singly Linked List.Given a linked list, write a function to reverse every alternate k nodes (where k is an input to the function) in an efficient way.
        //a.Inputs:   1->2->3->4->5->6->7->8->9->NULL and k = 3
        //b.Output:   3->2->1->4->5->6->9->8->7->NULL.
        //18-	WAP to Merge two sorted list in Sorted order.Don't use separate list just merge in first or second list itself
        //19-	Given a singly linked list, rotate the linked list counter-clockwise by k nodes where k is a given positive integer.
        //a.For example, if the given linked list is 10->20->30->40->50->60 and k is 4, the list should be modified to 50->60->10->20->30->40. Assume that k is smaller than the count of nodes in linked list.
        //20-	Sort linklist using Merge sort
        //21-	Swap Kth node from beginning with Kth node from end in a Linked List.Swapping of data is not allowed, only pointers should be changed
        //22-	Delete Node which have a greater value at right side
        //a.The list 12->15->10->11->5->6->2->3->NULL should be changed to 15->11->6->3->NULL.
        //b.Note that 12, 10, 5 and 2 have been deleted because there is a greater value on the right side.
        //23-	Given a singly linked list L0 -> L1 -> … -> Ln-1 -> Ln.
        //a.Rearrange the nodes in the list so that the new formed list is : L0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2 …
        //b.Input:  1 -> 2 -> 3 -> 4 -> 5
        //c.Output: 1 -> 5 -> 2 -> 4 -> 3
        //24-	Given a linked list where every node represents a linked list and contains two pointers of its type:
        //a.  (i) Pointer to next node in the main list(we call it ‘Next’ pointer in below code)
        //b.  (ii) Pointer to a linked list where this node is head (we call it ‘down’ pointer in below code).
        //c.	All linked lists are sorted
        //d.	Write a function flatten() to flatten the lists into a single linked list. The flattened linked list should also be sorted.
        //25-	Given two linked lists sorted in increasing order. Merge them such a way that the result list is in decreasing order (reverse order).
        #endregion

        #region Binary Tree/Binary Search Tree

        //1-	Insert node in BST
        //2-	Search a key in BST
        //3-	Inorder Traversal (Iterative/Recursive)
        //4-	Preorder Traversal (Iterative/Recursive)
        //5-	Postorder Traversal (Iterative/Recursive)
        //6-	Delete a node from BST
        //7-	Find a node with minimum value in BST
        //8-	Find inorder Predecessor and Successor of a given key in BST
        //9-	Check if Binary tree is balanced
        //10-	Check height of a tree
        //11-	Check is given tree is BST
        //12-	Function to find LCA of n1 and n2. The function assumes that both n1 and n2 are present in BST
        //13-	Given an array that stores a complete Binary Search Tree, write a function that efficiently prints the given array in ascending order. For example, given an array [4, 2, 5, 1, 3], the function should print 1, 2, 3, 4, 5
        //14-	Calculate size of a tree
        //15-	Determine if Two Trees are Identical, Two trees are identical when they have same data and arrangement of data is also same.
        //16-	WAP to Level Order Tree Traversal, Level order traversal of a tree is breadth first traversal for the tree.
        //17-	WAP to Level Order Tree Traversal in Reverse Order.
        //18-	Program to count leaf nodes in a binary tree.
        //19-	WAP to Level order traversal in spiral form
        //a.	METHOD1 : Two stacks
        //b.	METHOD 2: call each level with alternate bool value
        //20-	Given a sorted array. Write a function that creates a Balanced Binary Search Tree using array elements.
        //a.  1) Get the Middle of the array and make it root.
        //b.  2) Recursively do same for left half and right half.
        //i.Get the middle of left half and make it left child of the root
        //ii.Get the middle of right half and make it right child of the root
        //21-	Convert Sorted Linked list to balanced BST
        //22-	Check if a given Binary Tree is SumTree, A SumTree is a Binary Tree where the value of a node is equal to sum of the nodes present in its left subtree and right subtree.An empty tree is SumTree and sum of an empty tree can be considered as 0. A leaf node is also considered as SumTree.
        //a.eg : 26, 10, 3, 4, 6, 3
        //i.  1) If the node is a leaf node then sum of subtree rooted with this node is equal to value of this node.
        //ii. 2) If the node is not a leaf node then sum of subtree rooted with this node is twice the value of this node
        //23-	Check if a binary tree is subtree of another binary tree
        //24-	Two nodes of a BST are swapped, correct the BST. We can solve this in O(n) time and with a single traversal of the given BST. Since inorder traversal of BST is always a sorted array,
        //25-	Given a binary tree, print all root-to-leaf paths
        //26-	Print Ancestors of a given node in Binary Tree
        //27-	WAP to find the level of a node in BST, We are considering top level as 1.
        //28-	find a parent of a given key in BST
        //29-	Given the binary Tree and the two nodes say ‘p’ and ‘q’, determine whether the two nodes are cousins of each other or not. Two nodes are said to be cousins of each other if they are at same level of the Binary Tree and have different parents.
        //30-	WAP to Insert node in Binary tree in such a way where we can also use tree as linklist
        //31-	Given a binary tree populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.
        //a.Initially, all next pointers are set to NULL.
        //32 - Given a binary tree and a number, Write a function to find out whether there is a path from root to leaf with sum equal to given Number. for example : if Sum = 7 and there is path like 1,2 and 4 then return true
        //33 - Print Kth Largest element from BST tree
        //34 - Given two Binary Search Trees, find common nodes in them.In other words, find intersection of two BSTs.
        //35 - Given two values k1 and k2(where k1 < k2) and a root pointer to a Binary Search Tree.Print all the keys of tree in range k1 to k2.
        //36 - Given a binary tree, print it vertically
        //37 - Threaded Binary Tree.
        #endregion

        #region Dynamic Programming
        //1 - WAP to find the longest increasing sequence in Array
        //a.Input : 3,4,-1,0,6,2,3
        //b.Increasing sequence here is : 1)  3,4,6  2) -1,0,2,3 so longest increasing sequence length is 4.
        //2 - WAP to find the longest Bitonic sequence in Array, Bitonic sequence is a sequence which increases and then decreases
        //a.Input : 2,-1,4,3,5,-1,3,2
        //b.longest biotonic sequence here is : 2,3,5,3,2
        //c.output : 5
        //d.Logic is to find longest increasing sequnece from right and left in two diff array then find max from both and minus 1
        //3 - WAP to calculate Maximum Rectangular Histogram Area of given Array
        //4 - Write a program to calculate or find the maximum size of rectangle of 1 where matrix contains only 0 and 1 values.
        //5 - Given two sequences, print the longest subsequence present in both of them.Examples: LCS for input Sequences “ABCDGH” and “AEDFHR” is “ADH” of length 3.LCS for input Sequences “AGGTAB” and “GXTXAYB” is “GTAB” of length 4.
        //a.Formula : if matched : Diagonal Value +1
        //b.If not matched: MAX(Left, Up)
        //6 - WAP to find longest substring in a string
        //a.  if characters match then set value DigonalValue + 1
        //b.  if not matched then 0
        //7 - WAP to find the minimum number of operation Add/ Delete / Edit to convert string1 to string2
        //8 - Given a binary matrix consisting only 0s and 1s, find the maximum size square sub-matrix with all 1s.
        //9 - Given coin of certain denominator, how many possible ways are there to get the given total value, for example if there are 3 coins given and we need result 5 then how many ways are there to use coin to get 5
        //a.Coin = (1,2,3), Total = 5 : 
        //b.Different Ways to get 5 by combining 1,2,3 coins: (1,1,1,1,1), (1,1,1,2), (1,1,3), (2,3), (1,2,2)
        //10 - Find minimum number for coins use to pay certain amount!ex: Coins = { 1,5,6,8}, Amount = 11, Output: Min Number of coins : 2, Coins: 5,6
        //11 - Given a string, find the longest substring which is palindrome.
        // a.  if the given string is “forgeeksskeegfor”, the output should be “geeksskeeg”.
        //12 - Given a cost matrix cost[][]
        //and a position (m, n) in cost []
        //[], write a function that returns cost of minimum cost path to reach (m, n) from (0, 0). Each cell of the matrix represents a cost to traverse through that cell. Total cost of a path to reach (m, n) is sum of all the costs on that path (including both source and destination).
        //a.	You can only traverse down, right and diagonally lower cells from a given cell. i.e., from a given cell (i, j), cells (i+1, j), (i, j+1) and (i+1, j+1) can be traversed.
        //b.	You may assume that all costs are positive integers.
        #endregion

        #region Stack
        //1-	Create 3 Stack with equal size in an array
        //2-	Create K Stack in single array
        //3-	Sort stack
        //4-	Evaluate Postfix Expression
        //5-	Convert infix into postfix notation
        //6-	Print Binary Number
        //7-	Given an array, print the Next Greater Element (NGE) for every element. The Next greater Element for an element x is the first greater element on the right side of x in array.Elements for which no greater element exist. consider next greater element as -1.
        #endregion

        #region Question Asked In Interview
        // Shortest Path in Graph
        // if there is Path from one node to last node in Matrix, only right and down is allowed
        // Design MineSweeper Game
        #endregion

        #region Mock Interview Feedback
        #region Interview I - Find Group of Anagrams

        #region Question 
        //Find Group of Anagrams
        #endregion

        #region Feedback
        //in general you talked about sorting to check if strings are anagrams of each other which is good.
        //good test cases you came up with. in general, there are a lot of long silences and its sometimes difficult 
        //to understand your thought process.practice converting algorithm into code as we couldn't finish coding on time. 
        //best of luck!
        #endregion

        #endregion

        #region Interview II Find the maximum value by inserting “+”, “-”, “*” or “/” in given float numbers

        #region Question Find the maximum value by inserting “+”, “-”, “*” or “/” in given float numbers
        //using System;

        /*
        dfs/bfs
        greedy
        sliding window
        divide and conquer
        dp
        recursion

        Given a list of float numbers, insert “+”, “-”, “*” or “/” between each consecutive pair of numbers to 
        find the maximum value you can get. For simplicity, assume that all operators are of equal precedence order 
        and evaluation happens from left to right.

        vankaumnii@gmail.com

        Example:
        (1, 12, 3) -> 1 + 12 * 3  = 39

                1              [1]
           13 12 -11 1/12      [1,12]
           .....

        (5, 10, 4) ->
        (-1, 6, -7) - > 



        float getMaxNumber(float[] nums)...
        */

        //class Solution
        //    {
        //        static void Main(string[] args)
        //        {
        //            float[] nums = { 1, 12, -3 }; //33
        //                                          //[-39,33]
        //                                          //float[] nums={1, 12, 5}; //65

        //            float maxNumber = getMaxNumber(nums);

        //            Console.WriteLine(maxNumber);
        //        }

        //        private static float getMaxNumber(float[] nums)
        //        {
        //            // if nums length is < 1

        //            float[] maxResult = new float[2];

        //            if (nums.Length < 1)
        //            {
        //                return maxResult[0];
        //            }

        //            // if nums length is equal 1
        //            if (nums.Length == 1)
        //            {
        //                return nums[0];
        //            }

        //            for (int i = 0; i < nums.Length; i++)
        //            {
        //                maxResult = calculate(maxResult, nums[i]);
        //            }

        //            return maxResult[0] > maxResult[1] ? maxResult[0] : maxResult[1];

        //        }

        //        private static float[] calculate(float[] num1, float num2)
        //        {
        //            List<float> res = new List<float>();

        //            float[] resultMinMax = new float[2];
        //            float sumResult = num1 + num2;
        //            float multiplyResult = num1 * num2;
        //            float minusResult = num1 * num2;
        //            float divideResult = num1 / num2;

        //            resultMinMax[0] = MaxNumber(sumResult, multiplyResult, minusResult, divideResult);

        //            Console.WriteLine(resultMinMax[0]);

        //            resultMinMax[1] = MinNumber(sumResult, multiplyResult, minusResult, divideResult);

        //            Console.WriteLine(resultMinMax[1]);

        //            return resultMinMax;
        //        }

        //        private static float MaxNumber(float sumResult, float multiplyResult, float minusResult, float divideResult)
        //        {
        //            float finalMax = 0;
        //            finalMax = sumResult > multiplyResult ? sumResult : multiplyResult;

        //            finalMax = minusResult > finalMax ? minusResult : finalMax;

        //            finalMax = divideResult > finalMax ? divideResult : finalMax;

        //            return finalMax;
        //        }

        //        private static float MinNumber(float sumResult, float multiplyResult, float minusResult, float divideResult)
        //        {
        //            float finalMin = 0;
        //            finalMin = sumResult > multiplyResult ? multiplyResult : sumResult;

        //            finalMin = minusResult > finalMin ? finalMin : minusResult;

        //            finalMin = divideResult > finalMin ? finalMin : divideResult;

        //            return finalMin;
        //        }




        //    }
        #endregion

        #region Feedback
        //Candidate completed MSc in Computer Applications.Works as a contractor at Microsoft on conversational bots.

        //We worked on the question of Given a sequence of floats and operators, generate the max possible value.

        //Candidate originally proposed a solution that was not addressing all input cases. Once I pointed out, candidate needed further hints to come up with an algorithm.

        //Coding was relatively slow and code structure could be improved. There were also some bugs, e.g.not checking division by zero.

        //I think candidate has a lot of potential. I suggest candidate to continue practicing and make sure to review these algorithmic patterns:
        // DFS/BFS
        // greedy
        // sliding window
        // divide and conquer
        // recursion
        // dynamic programming.

        // Also, review topics of system design, since they may come up in the future interviews.
        #endregion

        #region temp solution
        //        using System;

        //public class Test
        //    {
        //        public static void Main()
        //        {
        //            float[] arr = { -2.0f, -3.0f, -4.0f, .5f };
        //            float intsum = 0;



        //            float resultSum = arr[0];
        //            for (int i = 1; i < arr.Length; i++)
        //            {
        //                resultSum = maxResult(resultSum, arr[i]);
        //            }



        //            Console.WriteLine(resultSum);
        //        }


        //        public static float maxResult(float a, float b)
        //        {
        //            return Math.Max(Math.Max(a + b, a * b),
        //            Math.Max(Math.Max(a / b, b / a), Math.Max(a - b, b - a)));
        //        }

        //    }
        #endregion
        #endregion

        #region Interview III Find maximum(or minimum) sum of a subarray of size k
        #region Question
        // Find maximum(or minimum) sum of a subarray of size k
        #endregion

        #region Feedback
        // He took longer than expected to solve the initial problem.There was no time for a follow up question. 
        // He lacks a structured algorithmic approach to problem solving.His initial code looked like a bunch of 
        // if else statements.
        // Missed corner cases and the solution initially had serious flaws, until I pointed it out.
        #endregion
        #endregion

        #region Interview IV Implement a basic calculator to evaluate a simple expression string
        // Great job with
        // - Communication
        // - Good clarifying questions
        // - Handling null cases
        // - Talking out loud
        // 1. Read the questions carefully
        // 2. Ask question about run and space complexity
        // 3. Ask about the scalability
        // -- before jump for the code
        // 4. Write the Algorithm on steps
        //   Needs improvement
        // - Practice coding with timers
        // - Nail down the algo.before jumping into the problem
        // - Ask about runtime/space complexity needs, "would the input fit in memory?"
        // - Think of these interviews as brainstorming sessions with friends.
        // - Try to write bug free code in the first go.

        // Question
        // Implement a basic calculator to evaluate a simple expression string.
        // The expression string contains only non-negative integers, +, -, *, / operators and empty spaces.The integer division should truncate toward zero.
        // You may assume that the given expression is always valid.
        //  Some examples:
        //  "3+2*2" = 7
        //  " 3/2 " = 1
        //  " 3+5 / 2 " = 5
        //  Note: Do not use the eval built-in library function. 
        #endregion

        #endregion

        // Sites for practicing

        // 1. Read the questions carefully
        // 2. Ask question about run and space complexity
        // 3. Ask about the scalability
        // -- before jump for the code
        // 4. Write the Algorithm on steps

        // there is PDF book also to refer - https://legacy.gitbook.com/book/hackingnote/coding-interview-solutions/details
        // https://evelynn.gitbooks.io/google-interview/read_n_characters_given_read4.html
        // https://github.com/tongzhang1994/Facebook-Interview-Coding
        // https://www.tutorialcup.com/string/program-print-permutations-string.htm
        // https://github.com/codeyu/LeetCode

        //https://leetcode.com/
        //https://www.programcreek.com
        //https://www.interviewbit.com/dashboard/
        //https://www.hackerrank.com/dashboard

        //System Design
        //https://www.hiredintech.com/classrooms/system-design/lesson/52

        //Few Github repositories

        // https://github.com/prakashthelight/software-engineer-interview
        // https://github.com/prakashthelight/my-eclipse-workspace

        // Good for Facebook and Google
        // https://github.com/orrsella/soft-eng-interview-prep

        // 1. Design Class and create your own iterator/ Implement your own IEnumrable

        // 2. Design Hashmap - REF: https://discuss.leetcode.com/topic/102606/design-a-hashmap


        //How to sort Class Objects IComparer

        //Singleton Pattern (http://csharpindepth.com/Articles/General/Singleton.aspx)

        //Deadlock
        //A deadlock is a situation in which two computer programs sharing the same resource are effectively preventing each other from accessing the resource, resulting in both programs ceasing to function.The earliest computer operating systems ran only one program at a time.

        //Help Link
        //https://miafish.wordpress.com/category/net/classes-and-structs/

        //https://discuss.leetcode.com/?page=1

        //http://www.cnblogs.com/EdwardLiu/tag/Leetcode/

        //http://bookshadow.com/weblog/2017/07/16/leetcode-maximum-average-subarray-ii/

        //List of Questions are - https://www.quora.com/What-are-the-questions-asked-in-an-Amazon-Online-Test-in-HackerRank

        //https://discuss.leetcode.com/topic/46161/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning

        //https://discuss.leetcode.com/topic/68976/sliding-window-algorithm-template-to-solve-all-the-leetcode-substring-search-problem

        // Type Script Book GitHub
        // https://basarat.gitbooks.io/typescript/content/docs/why-typescript.html

        //Denisa Prochazkova

        //Matt Rockow

        // Katerina Baranyuk        
        // Todays Task (12/08)

        //731	My Calendar II	34.8%	Medium
        //729	My Calendar I	39.9%	Medium
        //724	Find Pivot Index	41.1%	Easy
        //719	Find K-th Smallest Pair Distance	25.9%	Hard
        //718	Maximum Length of Repeated Subarray	39.8%	Medium

        #region Amazon Interview Practice Questions
        //Save all leaf nodes of a Binary tree in a Doubly Linked List by using Right node as Next node and Left Node as Previous Node.
        //Given an array, find the maximum j – i such that arr[j] > arr[i]
        //In a file there are 1 million words.Find 10 most frequent words in that file.
        //Find all nodes at k-distance from a given node in a binary tree
        //Construct a binary tree from given inorder and preorder traversals.
        //Return a tree such that each internal node stores sum of all its child nodes.Each leaf node stores zero.
        //Given a positive integer N, count all possible distinct binary strings of length N such that there are no consecutive 1’s.
        //Find sum of data of all leaves of a binary tree on same level and then multiply sums obtained of all levels.
        //Given the root to a binary tree, a value n and k.Find the sum of nodes at distance k from node with value n
        //Find the nth number that contains the digit k or is divisible by k. (2 <= k <= 9)
        //Given a directed graph.Construct another graph from given graph such that if path exists from vertices A to vertices B and from B to C, then path from A to C and from C to A also should exists.
        //Given a tree with edge weights, find any path in the tree with maximum sum of edges.
        #endregion

        #region Leetcode Interview Experience Questions Random (Practice Again)
        // Design Tiny Url
        // Remove Duplicates from Linked List
        // Find the Union and Intersection of sorted array
        // Minimum number of Appends needed to make a string palindrome
        /*Remove Alternate Duplicate characters from a char array you have to do it in Place.Like keeping only the odd occurences of each character.
          Example: Input: “you got beautiful eyes”
          Output: ”you gtbeaiful es”
          Allowed Time Complexity was O(n)
          and Space Complexity was O(1)*/
        // Clone a linked list with next and random pointer
        // Serialise and Deserialise a linked list with next and random pointer.
        // How will you implement linked list with 1 million nodes? How will you access 999999 th node? Give some optimal design strategy and implementation.
        // Reversal of Linked List in groups of K.
        // Check whether given binary tree is balanced or not.Definition was no two leaves should have height difference of greater than one.
        // Remove duplicates from string in place in O(n).
        // Connect nodes on same level in a binary tree.
        /* Given a matrix of characters and a word.
           you have to count the number of occurrences of that word in that matrix. you can move to any of the eight valid directions from current position.*/

        /* You are given an string as input which represents a path.You have to normalize that path inplace(NO EXTRA SPACE).
           e.g.input : "\a\b\c\..\..\file.txt"
           output: "\a\file.txt"*/

        // Least common ancestor of two nodes in a binary tree
        // Given two sorted arrays(with repetitive elements) find the kth minimum number from both arrays.
        // Find an element in a rotated array
        // Given two linked lists both represent a number.Create a linked list that contains its sum.
        // Given a binary search tree , print the path which has the sum equal to k and has minimum hops. i.e if there are multiple paths with the sum equal to k then print the path with minimum number of nodes.
        // A MxN matrix containing integers (positive, negative and zero’s). For every position containing 0, mark the corresponding row and column as 0.
        // Rotate MxN matrix by 90 degress.
        // Write a program to connect next left node in a binary tree.Also first node of each level should be pointing to last node of next level? (Without using Queue)
        // Convert a binary tree to its sum tree(each node is the sum of its children)
        // Implement hashmap on your own.Write good hashing function for string.

        /* Given an array, arrange the elements such that the number formed by concatenating the elements is highest.
           E.g.: input = [9, 93, 24, 6], the output should be: [9,93,6,24]. This is because if you concatenate all the numbers, 993624 is the highest number that can be formed.*/

        // Given a string, find the longest substring which is palindrome.
        // Given that integers are read from a data stream.Find median of elements read so for in efficient way. For simplicity assume there are no duplicates.
        // Write an efficient program for printing k largest elements in an array. Elements in array can be in any order.
        // Given unsorted array and a number K.Find 2 numbers such that sum is K.
        // Given n-ary tree. zigzag level order traversal.
        // Given string s and string t find whether all permutation of t is present as substring in s.
        // Design a stack which holds an integer value such that getMinimum() function should return the minimum element in the stack.Implement popMin() function which would pop minimum element from the original stack.

        /* Given a set of intervals like 5-10, 15-20, 25-40, 30-45, 50-100. Find the ith smallest number in these intervals. Assume there are no duplicate numbers.
           e.g:  1st smallest number = 5	  
           6th smallest number = 10	  
          7th smallest number = 15 and so on.*/

        // Given an array which is first strictly increasing and then strictly decreasing.Find an element in this array.
        // Given a string example : shoppingwithflipkartiseasy, Now we are given this string and a dictionary containing valid words , now we need to break the sentence into words separated by space.Output : shopping with flipkart is easy
        // Given a series 2,3,4,5,6,8,9,10,……, here in this series all the numbers are present which have factors only and only either 2,3 or 5. Need to write a node to generate nth number for the series . With best approach and complexity
        // Merge k sorted arrays.
        // Given a maze, a start point and end point find the shortest path to reach the end point from the starting point.
        // Given a sentence and a set of characters. Find the minimum window within which the set of characters can be found in the sentence in any order.
        /* You are given a string of 0’s and 1’s you have to find the number of substrings in the string which starts and end with a 1.
          eg : input : 0010110010
          output : 6*/

        /* You are given a mapping like a -> 1, b-> 2… z-> 26. You have to print all possible combinations of a given number using the above information.
           eg : input : 121
          output : aba, la, au*/

        /*Given a dictionary of 50,000 words.Given a phrase without spaces, add spaces to make it a proper sentence.
          e.g:input:  thequickbrownfoxjumpoverlazydog
          output: the quick brown fox jump over lazy dog*/

        /* Get the next bigger number using the same digits of a number.
           Eg, For 123456, next number would be 123465*/
        #endregion

        #region Preparation
        // Array
        // Anagram (5)
        // Best Time to Buy and Sale Stock (3)
        // House Robber (3)
        // Duplicate -> Find Duplicate (3)
        // Duplicate -> Remove Duplicate (5)
        // Important ->  Done till Search Insert Position Array (17)            
        // Intersection Array (2)
        // Interval - (5)
        // Largest Number - (4)
        // Majority Element - (2)
        // Missing Number - (4)
        // Move Zeros (2)
        // Pascal Triangle - (2)
        // Rotate Array (5)
        // SubArray -> CalculateMaximumSubArray - (4)
        // SubArray -> (8)
        // Sub Sequence -> (6)
        // Trapping Rain Water Problem - (2)
        // Matrix -> Island Problems - (8)
        // Matrix - (12)
        // Linked List - (20)
        // Backtrack - (7)
        // Basic Calculator - (2)
        // Design - (13)
        // Tree -> BST -> ConvertBST (3)
        // Tree -> BST -> Important (3)
        // Tree -> BT -> Basics (5)
        // Tree -> BT -> Level Order Tree Traversal (15)
        // Excel Column - (2)

        // ##Pending
        // Array String -> 
        // Coin Problems
        // Games
        // IntegerToRomanWords
        // Paranthesis
        // Polish Notation
        // PowerOf
        // Tree
        // Trick
        // SE Interview Questions like JS, Best practices
        #endregion

        #region Date Oct Preparation for TeraData and Microsoft
        // Done - Subsets(https://leetcode.com/problems/subsets/description/)
        // Done - Reverse Linked List (https://leetcode.com/problems/reverse-linked-list/description/) (Recursively and Iteratively)
        // Done - Valid Binary Search Tree(https://leetcode.com/problems/validate-binary-search-tree/description/)
        // Done - Read N Characters given Read4 II(https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/description/)
        // Done - Serialize and Deserialize a binary tree(https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/)
        // Done - Evaluate Reverse Polish Notation (LC # 150) - Medium (https://leetcode.com/problems/evaluate-reverse-polish-notation/description/)
        // Done - Convert infix to postfix expression
        // Done - Two Sum - Data structure design (LC # 170) - Easy (https://leetcode.com/problems/two-sum-iii-data-structure-design/description/)
        // Done - Two Sum
        // Done - 3 Sum
        // Done - 3 Sum Closet
        // Done - Given a contiguous sequence of numbers in which each number repeats thrice, there is exactly one missing number. Find the missing number.
        // Done - String compression (https://leetcode.com/problems/string-compression/description/)
        // Done - Given a compressed string in which a number followed by [] indicate how many times those characters occur, decompress the string Eg. : a3[b2[c1[d]]] e will be decompressed as abcdcdbcdcdbcdcde. Assume the string is well formed and number will always be followed by a[].
        // Done - Verify if a given matrix is a Toeplitz matrix (https://leetcode.com/problems/toeplitz-matrix/description/)
        // Done - Trapping Rain Water I - (https://leetcode.com/problems/container-with-most-water/description/)
        // Done - Trapping Rain Water II - (https://leetcode.com/problems/trapping-rain-water/description/)
        // Done - House Robber I (https://leetcode.com/problems/house-robber/description/)
        // Done - House Robber II (https://leetcode.com/problems/house-robber-ii/description/)
        // Done - House Robber III (https://leetcode.com/problems/house-robber-iii/description/)
        // Done - Minimum Number of Platforms Required for a Railway/Bus Station (https://www.geeksforgeeks.org/minimum-number-platforms-required-railwaybus-station/)
        // Done - All Unique Possible Paths without obsetical (Top Left - Bottom Right) - Where Robot can move Forward only Right -> Down (https://leetcode.com/problems/unique-paths/description/)
        // Done - All Unique Possible Paths with obsetical (Top Left - Bottom Right) - Where Robot can move Forward only Right -> Down (https://leetcode.com/problems/unique-paths-ii/description/)
        // Done - Excel Column Title Column Number
        // Done - Excel Column Number Column Title
        // Done - Return Elements from Spiral Matrix 
        // Done - Fill Elements in Matrix using Spiral Form
        

        #endregion
    }
}
